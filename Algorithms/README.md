## 第1节：数据结构与算法基础
### 01 算法引入
**1.1第一次尝试 **
>先来看一道题:
如果 a+b+c=1000，且 a^2+b^2=c^2（a,b,c 为自然数），如何求出所有a、b、c可能的组合?

```python
# 思路一：枚举法
"""
a =0
b =1
c = 0~1000
时间复杂度：T(n) = n*n*n = n^3
"""
import time
start_time = time.time()
for a in range(0, 1001):
    for b in range(0,1001):
        for c in range(0,1001):
            if a+b+c == 1000 and a**2 + b**2 == c**2:
                print("a,b,c: %d,%d,%d"%(a,b,c))
end_time = time.time()
print("总共用时: %d"%(end_time - start_time))
print("Finished!!!")
```
**输出：**
```python
a,b,c: 0,500,500
a,b,c: 200,375,425
a,b,c: 375,200,425
a,b,c: 500,0,500
总共用时: 662   #注意运行的时间:662秒
Finished!!!
```
**1.2算法的提出**  

**算法的概念**  
计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。  
**算法是独立存在的一种解决问题的方法和思想。它不依赖于实现的语言。** 算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等），我们现在是在用Python语言进行描述实现。  
>**算法的五大特性**  
输入: 算法具有0个或多个输入  
输出: 算法至少有1个或多个输出  
有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成  
确定性：算法中的每一步都有确定的含义，不会出现二义性  
可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成

**1.3第二次尝试**
```python
#思路二
"""
a =0~1000
b =0~1000
c = 1000-a-b
时间复杂度为：T(n) = n * n *(1+max(1,0)) = n^2*2 = O(n^2)
注：分支结构，时间复杂度取最大值(用max)
"""
import time
start_time = time.time()
for a in range(0,1001):
    for b in range(0,1001):
        c = 1000-a-b
        if a**2 + b**2 == c**2:
            print("a,b,c: %d,%d,%d" % (a, b, c))
end_time = time.time()
print("总共用时: %d s"%(end_time - start_time))
print("Finished!!!")
```
**输出：**
```python
a,b,c: 0,500,500
a,b,c: 200,375,425
a,b,c: 375,200,425
a,b,c: 500,0,500
总共用时: 3 s   ##注意运行的时间:3秒
Finished!!!
```

**1.4算法效率衡量**  

单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！  
假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，很可能运行的时间并不会比在我们的电脑中运行算法一的时间快多少。  
程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。

那么如何才能客观的评判一个算法的优劣呢？  

**时间复杂度与“大O记法”**  
假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。  
虽然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。   

对于算法的时间效率，我们可以用“大O记法”来表示。  
**“大O记法”**： 对于单调的整数函数f，如果存在一个整数函数g和实常数c>0，使得对于充分大的n总有f(n)<=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。

**时间复杂度：**假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)  
>时间复杂度狭义上落实到衡量标准是用运算步骤衡量(以思路一为例)  
T(n) = n^3 * 2  
T(n) = n^3 * 10  
T(n) = k*g(n) + c  
g(n) = n^3  
g(n)是T(n)的一个渐进函数,是一个时间复杂度的大O表示法  

**如何理解“大O记法**  
对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，**最重要的是其数量级和趋势**，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为3n^2和100n^2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为n^2级。  

**最坏时间复杂度**  
>分析算法时，存在几种可能的考虑：  
- 算法完成工作最少需要多少基本操作，即**最优时间复杂度 **
- 算法完成工作最多需要多少基本操作，即**最坏时间复杂度**  
- 算法完成工作平均需要多少基本操作，即平均时间复杂度

对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。  
对于**最坏时间复杂度**，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。  
对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。  
**因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。**  

### **时间复杂度的几条基本计算规则**

1. 基本操作，即只有常数项，认为其时间复杂度为O(1)
2. 顺序结构，时间复杂度按**加法**进行计算
3. 循环结构，时间复杂度按**乘法**进行计算
4. 分支结构，时间复杂度取**最大值**
5. 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
6. 在没有特殊说明时，我们所分析的算法的时间复杂度都是指**最坏时间复杂度** 



对于1.3的思路二，时间复杂度为：T(n) = n \* n \* (1+max(1,0)) = n^2*2 = O(n^2)

